---
authors: Alexander Klizhentas (sasha@gravitational.com), Brian Joerger (bjoerger@gravitational.com)
state: draft
---

# RFD 10 - API and Client Libraries

## What

- Unify Golang Client experience.
- Automatically generate API documentation using [pkg.go.dev](https://pkg.go.dev/).

## Why

There are several problems with the Teleport Go client libraries:

* The [Go client example](https://github.com/gravitational/teleport/tree/branch/5.0/examples/go-client) pulls the entire teleport package and all of its dependencies as a dependency. Most of these dependencies include internal server logic, such as `lib/auth`.
* There is no separate client library with guarantees of compatibility with specific version of Teleport. See examples [here](https://github.com/kubernetes/client-go#compatibility-matrix).
* Some client logic is residing in [plugins](https://github.com/gravitational/teleport-plugins/blob/master/access/access.go), while other logic is in `teleport/lib` packages.
* It's impossible to generate the library in any other language other than Go due to an unclear API surface.
* Code in `lib/auth` uses some concepts unfamiliar to Go users. For example, it deals with tls certificates at a low level:
```go
// connectClient establishes a gRPC connection to an auth server.
func connectClient() (*auth.Client, error) {
    tlsConfig, err := LoadTLSConfig("certs/api-admin.crt", "certs/api-admin.key", "certs/api-admin.cas")
    if err != nil {
        return nil, fmt.Errorf("Failed to setup TLS config: %v", err)
    }

    // must parse addr list panics and is not necessary
    authServerAddr := utils.MustParseAddrList("127.0.0.1:3025")
    clientConfig := auth.ClientConfig{Addrs: authServerAddr, TLS: tlsConfig}

    // TLS client is the only client
    return auth.NewTLSClient(clientConfig)
}
```

## Details

A new `api` package will be made these new features and any existing Teleport Auth client logic, most of which is is currently in `teleport/lib/auth/clt.go`. The new package will only support Teleport's gRPC client which will gradually replace the deprecated HTTP client. Other logic such as the web client and certificate reading logic will also be moved to the `api` package. 

The `api` package will be made a Go module, with no dependency on Teleport libraries. This will make it easy to import the API client with a small import footprint. Users will be able to run `go get github.com/gravitational/teleport/api` to get the latest version of the client and get started.

The client will also gain several new quality of life improvements, including credential loaders, automatic server version checking, better docs, and more language implementations.

### Make independent api package

Move the API client and its dependencies to the new `api` package to keep Teleport's API layer unified. all API client dependencies should be moved to the `api` package. 

`api` package file structure:
```
teleport/ 
└── api/
    ├── client
    |   ├── proto
    │   |   ├── authservice.proto
    │   |   └── authservice.pb.go
    │   └── client.go
    ├── types
    │   ├── events
    │   |   ├──events.proto
    │   |   └──events.pb.go
    │   ├── wrappers
    │   |   ├──wrappers.proto
    │   |   └──wrappers.pb.go
    │   ├── types.proto
    |   └── types.pb.go
    ├── go.mod
    ├── go.sum
    ... utils, defaults, constants, and other limited api dependencies
```

#### Backwards compatibility

Use Go's type aliases to refactor code into the `api` package while maintaining backwards compatibility in the main `teleport` package. These aliases will be removed after one major version (v7.0.0).

```go
// Preserve full backwards compatibility
type services.Role = types.Role
type auth.Service = proto.Service
```

#### Track dependencies

Teleport services, auth client, and proto generated files are all dependent on each other in a convoluted dependency graph. The goal is to make the dependency graph look like `Go stdlib <- types <- proto <- client`, rather than `teleport libraries <- services <- proto <- client`.

teleport libraries have a large and growing number of dependencies, while the Go stdlib, types package, and proto package can be limited to a select few dependencies. This will help to clarify the separation between api and business logic and make the client more language agnostic.

Track `api/go.mod` and minimize its dependencies. Some basic dependencies are unavoidable:
  * `gravitational/trace`
  * `google.golang.org/grpc`
  * `golang.org/x/net`
  * `golang.org/x/crypto`
  * `github.com/stretchr/testify`
  * indirect dependencies

If the list grows beyond 20 dependencies and indirect dependencies, this dependency issue should be revisited for better tracking mechanisms.

##### Deprecate the `lib/auth.Client`

Move relevant gRPC related `lib/auth.Client` code to `api/client`. Move the protobuf files to `client/proto`, along with any other client code that it depends on.

Leave the `lib/auth.Client` intact for backwards compatibility, internal use, and to retain functionality of the HTTP client until it has been fully deprecated. Necessary endpoints should be implemented in the gRPC client, rather than moving the HTTP client to the new `api` package.

#### Separate Teleport services from protobuf types

Currently, `lib/services` holds the protobuf files and types that the `lib/auth.Client` depends on. These types and proto files must be moved to `api/types` to remove the dependency on `lib/services`, as well as to draw a clear distinction between client logic and business logic.

Some logic found in this package are beyond the scope of the external client and should be refactored. For example into functions to remain in `lib/services`. For example, in `lib/services/role`, `role.CheckAndSetDefaults` has some business logic that should remain on the server side. Therefore that logic should be extracted into a new function, `ValidateRole`, and kept in `lib/services/role.go` rather than `api/types/role.go`.

```go
// api/types/role.go
(r *RoleV3) CheckAndSetDefaults() error {
  ... basic validation with business logic extracted
}
```

```go
// lib/services/role.go
func ValidateRole(r types.Role) error {
  ... business logic
}
```

#### Deprecate the `lib/auth.Client`

The new API client should be embedded in the `lib/auth.Client` during the deprecation process. That way new and existing endpoints can be added to the `api/client` and embedded in the `lib/auth.Client`.

There is [issue](https://github.com/gravitational/teleport/issues/6394) used to track remaining endpoints that need to be converted to gRPC. 

As this work is carried out, the `lib/auth.Client` should be adapted to attempt to make gRPC requests before falling back to HTTP in the case where the server version is older than the client version. These fallback methods should be moved to `lib/auth/httpfallback.go` to simplify the deprecation process.

Once all necessary endpoints have been added in gRPC, the gRPC client can completely replace the existing `lib/auth.Client`. At this point the underlying gRPC server will be the same, so the transition should be simple.

### api module

The api package will be made a sub module and dependency of teleport.

Users will be able to get the latest api version by using `go get github.com/teleport/api`.

#### versioning

Go module versions can automatically be pushed with git tags. Since the api module is a sub module, its version tags will look like `git tag api/vX.Y.Z`. This makes it easy to have the api match its corresponding teleport version, and therefore follow [Teleport versioning](https://github.com/gravitational/teleport/blob/master/rfd/0012-teleport-versioning.md). 

Straying from the Teleport versions and instead following semver is an option, but this does not have much merit from a product perspective. It would be more confusing for users and developers to reason about version compatibility with other Teleport binaries, and would be awkard to market alongside different Teleport versions.

#### releases

Since Teleport has a major version above 2, the api should ideally follow the [v2+ Go Module release guide](https://github.com/golang/go/wiki/Modules#releasing-modules-v2-or-higher) by appending a `vX` suffix to the gomodule import path on each major release. However, there are a few options around this:

*1) Follow the guidelines by appending the `vX` suffix*

The import path for each major version `X` would look like `github.com/gravitational/teleport/api/vX`. Each reference to the `api` package within the teleport repository will need to be updated before each major release.

Users will be able to import a specific version with `go get github.com/teleport/api@vX.Y.Z`.

Pros
 - It accurately follows guidelines which may avoid issues down the road.
 - Go Module users will be familiar with this approach.

Cons
 - Semver is implied when using this approach, which may actually confuse users and discourage version upgrades. 
    - In semver major upgrades are expected to be backwards incompatible, but Teleport promises a full major version of compatibility.
    - The amount of major upgrades may be suprising for most Go Module users, though there are other outliers out there (v10+).
 - Managing the `vX` suffix may be a pain, since all import paths in teleport wil have to be updated before each major release.
   - This will also lead to annoying but likely easy to fix merge conflicts on backport PRs.

*2) Ignore the guidelines and accept the `+incompatible` suffix.*

If a package has not "opted in" to go modules by following the `vX` suffix rule, but it has been given a valid semver git tag, it will be published with the `+incompatible` suffix. For example, [teleport v4.3.10](https://pkg.go.dev/github.com/gravitational/teleport@v4.3.10+incompatible) has been published with the incompatible suffix.

Users will be able to import a specific version with `go get github.com/teleport/api@vX.Y.Z+incompatible`.

Pros
 - Easy to develop, doesn't require any special steps outside of tagging it with the teleport release.
 - Since the `+incompatible` flag implies that we don't follow semver, this may lead users to seek out the Teleport versioning specification, which will more accurately describe the api versions.

Cons
 - The incompatible flag is a bit alarming, especially to unfamiliar Go Module users.
 - Go Modules may eventually have another preventative measure to ensure the `vX` rule is followed.

*3) Why not both?*

Since we can start tagging the client with the `+incompatible` suffix without any major additional work, we could start out with this option. We can then assess any difficulties that arise from this option and switch to using the `vX` approach later on.

The recommendation for switching from `+incompatible` to `vX` is to bump the module by a major version. Since Teleport generally has major releases four times a year, there isn't a large opportunity cost associated with waiting a major version or two.

Additionally, if no choice is made right away, the api will be versioned as v0.0.0-[random-string]. Getting the latest version with `go get github.com/teleport/api` will get the most recent version in terms of time rather than semver/teleport version, which is easily the most confusing option for users. For this reason it's important to start tagging the version as soon as possible.

### Client experience improvements

This is a list of quality of life improvments for users of the api client. 

#### Go native user experience

Achieve the user experience in Client with a simplified client constructor. The client should be able to retrieve credentials during client initialization and handle errors. This should also transparently handle dialing via a proxy.

```go
import (
   "github.com/gravitational/teleport/api/client"
)

func main() {
  // TLS client is the only TLS client supported in teleport
  client, err := client.New(client.Config{
    Addrs: []string{"localhost:3025"},
    // ContextDialer is an optional context dialer
    ContextDialer: net.DialContext,
    // direct TLS credentials config
    Credentials: []client.Credentials{
      client.TLSCreds(tls.Config),
    }
  })
  ...
  defer client.Close()

  ping, err := client.Ping()
  ...
  fmt.Printf("Ping: %v\n", ping.Version)
}
```

```bash
$ go mod init
$ go run main.go
```

#### Credential providers

Support multiple credential providers:
  * `client.LoadTLS(*tls.Config)` loads creds from TLS config.
  * `client.LoadKeyPair("crt_path", "key_path", "cas_path")` loads creds from tls certificates.
  * `client.LoadProfile("profile_path", "profile_name")` loads creds from the users default or specified tsh profile.
  * `client.LoadIdentityFile("identity_file_path")` loads creds from an identity file.

Support tunnel address discovery from the web proxy, as well as tunnel proxy connectivity using ssh certificates. Since tsh profiles have ssh certificates and the web proxy address, LoadProfile should be able to load the client without any user input. The user can simply `tsh login` and then the client will retrieve their credentials. This mirrors the functionality that `tctl` offers.

```go
// for testing, use client spec that loads tunnel dialer and certificates from profile
client, err := client.New(client.Config{
  Credentials: client.Credentials{
    client.LoadProfile("", ""),
  },
})
```

```bash
$ tsh login
# try client
$ go run main.go
```

#### Automatically reload credentials

Credential loaders should detect underlying file changes and automatically reload credentials and update the grpc transport.

#### Automatically check server version

The client automatically verify that its version is compatible with the server's version by calling `Ping` and during client initialization, similarly to how tsh does.

The client will fail to initialize if the the versions are not compatible. The user can override this by providing `SkipVersionCheck: true` in `client.Config` to avoid blocking users that are in the middle of upgrading.

### Move Access requests code into client

Move `access` workflows code into `client` subpackage with new name `workflows`:

https://github.com/gravitational/teleport-plugins/tree/master/access

Instead of a separate client, `workflows` becomes a subpackage of the api client:

```go
import (
   "github.com/gravitational/teleport/api/client"
   "github.com/gravitational/teleport/api/client/workflows"
)

func main() {
   client, err := client.New(...)
   watcher, err := workflows.NewWatcher(ctx, client, workflows.Watch{State: ...})
   ...
   defer watcher.Close()

```

#### Provide simplified high level access hooks

Access hooks are too low level, add simple handler similar to http server design
with a router:

```go

func myTeamRequest(ctx context.Context, req access.Request) (access.Request, error) {
  return req, trace.AccessDenied("access denied")
}


func main() {
router := access.Router()
  // handle access requests from my team only
  router.HandleFunc(router.Match{Traits: Trait("team", "myteam")}
  srv := access.Server{
     Client: clt,
     Handler: router,
  }
```


### Improve API documentation user experience

Code comments throughout the api package will be thourough and user focused. There will be examples and in depth explanations of user facing functions as needed. As a result, the automatically generated [pkg.go.dev](https://pkg.go.dev/github.com/gravitational/teleport/api/client) will be the main source of documentation.

For documentation outside of the scope of code comments, the api [reference docs](https://goteleport.com/docs/ver/6.2/reference/api/) will be rewritten with a `Getting Started` and `Architecture` section, as well as many links that point back to the pkg.go.dev docs.

### Add Python Client

Once the protobuf schema has been detangled from the `teleport/lib` code, it should be easy to create a bare bones `python` version of the Auth client. Python will be the first langauge of many new client libary implementations.

```bash
ls github.com/gravitational/teleport
api/
python/

$ pip install teleport-client
```

```python
import teleport

client = teleport.client(addr=...)
client.tokens()
```

Port router code

```python
@access.handle(clt, path=access.trait("team")):
def handle(req):
   if req.user == "bob":
      raise access.Denied("access denied")
```

Update docs to include the `python` variant of the client as well.
